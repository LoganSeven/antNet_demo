# src/python/ffi/backend_api.py
# High-level Python wrapper for the C AntNet backend.
# security/hardening: negative C return code ⇒ ValueError
# unexpected positive non-zero ⇒ RuntimeError

from __future__ import annotations
import os
import sys
import importlib

from consts._generated.error_codes_generated import ERR_SUCCESS
from structs._generated.auto_structs import AppConfig  # generated by tools/generate_structs.py

# ----------------------------------------------------------------------
#  Dynamic import of backend_cffi (the CFFI-generated glue module)
# ----------------------------------------------------------------------
def _ensure_backend_cffi_loaded():
    """
    Attempt to import backend_cffi.
    If not found, prepend common build paths to sys.path and retry exactly once.
    """
    try:
        return importlib.import_module("backend_cffi")
    except ModuleNotFoundError:
        here = os.path.dirname(__file__)
        root = os.path.abspath(os.path.join(here, "..", "..", ".."))
        for p in (
            os.path.join(root, "build", "python"),
            os.path.join(root, "src",  "python"),
            os.path.join(root, "src",  "python", "ffi"),
        ):
            if p not in sys.path and os.path.isdir(p):
                sys.path.insert(0, p)
        return importlib.import_module("backend_cffi")

_backend = _ensure_backend_cffi_loaded()
ffi, lib = _backend.ffi, _backend.lib  # type: ignore

# ----------------------------------------------------------------------
#  AntNetWrapper – thin, pythonic façade over the native API
# ----------------------------------------------------------------------
class AntNetWrapper:
    """
    Wrapper supports three constructors:
        AntNetWrapper.from_config("file.ini")
        AntNetWrapper(app_config={…})
        AntNetWrapper(node_count, min_hops, max_hops)
    """

    # ─────────────────────────────── ctor ────────────────────────────
    def __init__(
        self,
        node_count: int | None = None,
        min_hops:   int | None = None,
        max_hops:   int | None = None,
        from_config: str | None = None,
        app_config:  dict | None = None,
    ):
        self.context_id: int | None = None

        # 1) ini-file
        if from_config is not None:
            if not isinstance(from_config, str):
                raise ValueError("from_config must be a str path to .ini")
            rc = lib.antnet_init_from_config(from_config.encode("utf-8"))
            if rc < 0:
                raise ValueError(f"antnet_init_from_config failed with code {rc}")
            self.context_id = rc
            return

        # 2) dict-based config
        if app_config is not None:
            if not isinstance(app_config, dict):
                raise ValueError("app_config must be a dict")
            node_count = app_config["set_nb_nodes"]
            min_hops   = app_config["min_hops"]
            max_hops   = app_config["max_hops"]

        # 3) raw numbers
        if node_count is not None and min_hops is not None and max_hops is not None:
            rc = lib.antnet_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"antnet_initialize failed with code {rc}")
            self.context_id = rc
            return

        raise ValueError(
            "Need either from_config=…, or app_config=…, "
            "or node_count/min_hops/max_hops."
        )

    # convenience
    @classmethod
    def from_config(cls, path: str) -> "AntNetWrapper":
        return cls(from_config=path)

    # ─────────────────────── configuration read ─────────────────────
    def get_config(self) -> AppConfig:
        """
        Returns the current AppConfig as a dict with new fields:
          nb_ants, set_nb_nodes, min_hops, max_hops,
          default_min_delay, default_max_delay, death_delay,
          under_attack_id, attack_started,
          simulate_ddos, show_random_performance, show_brute_performance,
          ranking_alpha, ranking_beta, ranking_gamma,
          ant_alpha, ant_beta, ant_Q, ant_evaporation
        """
        if self.context_id is None:
            raise ValueError("No valid context_id")
        cfg_ptr = ffi.new("AppConfig*")
        rc = lib.antnet_get_config(self.context_id, cfg_ptr)
        if rc != 0:
            raise ValueError(f"antnet_get_config failed with code {rc}")
        return {
            "nb_ants":               cfg_ptr.nb_ants,
            "set_nb_nodes":          cfg_ptr.set_nb_nodes,
            "min_hops":              cfg_ptr.min_hops,
            "max_hops":              cfg_ptr.max_hops,
            "default_min_delay":     cfg_ptr.default_min_delay,
            "default_max_delay":     cfg_ptr.default_max_delay,
            "death_delay":           cfg_ptr.death_delay,
            "under_attack_id":       cfg_ptr.under_attack_id,
            "attack_started":        bool(cfg_ptr.attack_started),
            "simulate_ddos":         bool(cfg_ptr.simulate_ddos),
            "show_random_performance": bool(cfg_ptr.show_random_performance),
            "show_brute_performance":  bool(cfg_ptr.show_brute_performance),
            "ranking_alpha":         float(cfg_ptr.ranking_alpha),
            "ranking_beta":          float(cfg_ptr.ranking_beta),
            "ranking_gamma":         float(cfg_ptr.ranking_gamma),
            "ant_alpha":             float(cfg_ptr.ant_alpha),
            "ant_beta":              float(cfg_ptr.ant_beta),
            "ant_Q":                 float(cfg_ptr.ant_Q),
            "ant_evaporation":       float(cfg_ptr.ant_evaporation),
        }

    # ────────────────────────── iteration ───────────────────────────
    def run_iteration(self) -> None:
        rc = lib.antnet_run_iteration(self.context_id)
        if rc == ERR_SUCCESS:
            return
        if rc < 0:
            raise ValueError(f"run_iteration failed with code {rc}")
        raise RuntimeError(f"run_iteration returned unexpected {rc}")

    # ─────────────────────── best-path helper ───────────────────────
    def get_best_path_struct(self):
        max_nodes = 1024
        nodes_buf = ffi.new("int[]", max_nodes)
        len_ptr   = ffi.new("int*")
        lat_ptr   = ffi.new("int*")

        rc = lib.antnet_get_best_path(self.context_id, nodes_buf, max_nodes, len_ptr, lat_ptr)
        if rc != 0:
            raise ValueError(f"get_best_path failed with code {rc}")
        return {
            "nodes": [nodes_buf[i] for i in range(len_ptr[0])],
            "total_latency": lat_ptr[0],
        }

    # ───────────────────── topology replacement ─────────────────────
    def update_topology(self, nodes: list[dict], edges: list[dict]) -> None:
        """
        Push a new node/edge array into the backend.
        Each node → {"node_id": int >=0, "delay_ms": int >=0}
        Each edge → {"from_id": int >=0, "to_id":   int >=0}
        """
        if self.context_id is None:
            raise ValueError("Invalid context_id")

        n, e = len(nodes), len(edges)
        if n == 0 or e == 0:
            raise ValueError("Empty node or edge list")

        node_arr = ffi.new("NodeData[]", n)
        edge_arr = ffi.new("EdgeData[]", e)

        for i, nd in enumerate(nodes):
            node_id  = nd.get("node_id")
            delay_ms = nd.get("delay_ms")
            if not isinstance(node_id, int) or node_id < 0:
                raise ValueError(f"Invalid node_id: {node_id}")
            if not isinstance(delay_ms, int) or delay_ms < 0:
                raise ValueError(f"Invalid delay_ms: {delay_ms}")
            node_arr[i].node_id  = node_id
            node_arr[i].delay_ms = delay_ms
            node_arr[i].x = node_arr[i].y = 0.0
            node_arr[i].radius = 0

        for j, ed in enumerate(edges):
            from_id = ed.get("from_id")
            to_id   = ed.get("to_id")
            if not isinstance(from_id, int) or from_id < 0:
                raise ValueError(f"Invalid from_id: {from_id}")
            if not isinstance(to_id, int) or to_id < 0:
                raise ValueError(f"Invalid to_id: {to_id}")
            edge_arr[j].from_id = from_id
            edge_arr[j].to_id   = to_id

        rc = lib.antnet_update_topology(self.context_id, node_arr, n, edge_arr, e)
        if rc == 0:
            return
        if rc < 0:
            raise ValueError(f"update_topology failed with code {rc}")
        raise RuntimeError(f"update_topology returned unexpected {rc}")

    # ───────────────────── run all solvers in C ─────────────────────
    def run_all_solvers(self):
        max_nodes = 1024
        a_nodes = ffi.new("int[]", max_nodes)
        r_nodes = ffi.new("int[]", max_nodes)
        b_nodes = ffi.new("int[]", max_nodes)

        a_len = ffi.new("int*"); r_len = ffi.new("int*"); b_len = ffi.new("int*")
        a_lat = ffi.new("int*"); r_lat = ffi.new("int*"); b_lat = ffi.new("int*")

        rc = lib.antnet_run_all_solvers(
            self.context_id,
            a_nodes, max_nodes, a_len, a_lat,
            r_nodes, max_nodes, r_len, r_lat,
            b_nodes, max_nodes, b_len, b_lat
        )
        if rc != 0:
            raise ValueError(f"run_all_solvers failed with code {rc}")

        return {
            "aco": {
                "nodes": [a_nodes[i] for i in range(a_len[0])],
                "total_latency": a_lat[0],
            },
            "random": {
                "nodes": [r_nodes[i] for i in range(r_len[0])],
                "total_latency": r_lat[0],
            },
            "brute": {
                "nodes": [b_nodes[i] for i in range(b_len[0])],
                "total_latency": b_lat[0],
            },
        }

    # ───────────────────── pheromone matrix read ────────────────────
    def get_pheromone_matrix(self) -> list[float]:
        if self.context_id is None:
            raise ValueError("Invalid context_id")
        max_floats = 1024 * 1024
        buf = ffi.new("float[]", max_floats)
        rc = lib.antnet_get_pheromone_matrix(self.context_id, buf, max_floats)
        if rc < 0:
            raise ValueError(f"get_pheromone_matrix failed with code {rc}")
        return [buf[i] for i in range(rc)]

    # ─────────────────────────── ranking ────────────────────────────
    def get_algo_ranking(self) -> list[dict]:
        if self.context_id is None:
            raise ValueError("Invalid context_id")
        max_algs = 8
        rank_arr = ffi.new("RankingEntry[]", max_algs)
        rc = lib.antnet_get_algo_ranking(self.context_id, rank_arr, max_algs)
        if rc < 0:
            raise ValueError(f"get_algo_ranking failed with code {rc}")
        result: list[dict] = []
        for i in range(rc):
            name = ffi.string(rank_arr[i].name).decode("utf-8", "ignore")
            result.append({
                "name":       name,
                "score":      rank_arr[i].score,
                "latency_ms": rank_arr[i].latency_ms,
            })
        return result

    # ───────────────────────── shutdown ─────────────────────────────
    def shutdown(self) -> None:
        if self.context_id is None:
            return
        rc = lib.antnet_shutdown(self.context_id)
        if rc == 0:
            self.context_id = None
            return
        if rc < 0:
            raise ValueError(f"antnet_shutdown failed with code {rc}")
        raise RuntimeError(f"antnet_shutdown returned unexpected {rc}")

    def __del__(self):
        try:
            self.shutdown()
        except Exception:
            pass


    def antnet_get_aco_params(self, out_alpha, out_beta, out_Q, out_evaporation, out_num_ants):
        """AUTO-GENERATED thin wrapper for lib.antnet_get_aco_params.
    [File: Unknown] MUST BE IMPLEMENTED 🟥
    Parameter signature (excluding context_id): [('float*', 'out_alpha'), ('float*', 'out_beta'), ('float*', 'out_Q'), ('float*', 'out_evaporation'), ('int*', 'out_num_ants')]"""
        if self.context_id is None:
            raise ValueError("Invalid context_id for antnet_get_aco_params")
        rc = lib.antnet_get_aco_params(self.context_id, out_alpha, out_beta, out_Q, out_evaporation, out_num_ants)
        if rc in (0, ERR_SUCCESS):
            return rc
        if rc < 0:
            raise ValueError("antnet_get_aco_params failed with code {rc}")
        raise RuntimeError("antnet_get_aco_params returned unexpected {rc}")

    def antnet_get_sasa_params(self, out_alpha, out_beta, out_gamma):
        """AUTO-GENERATED thin wrapper for lib.antnet_get_sasa_params.
    [File: Unknown] MUST BE IMPLEMENTED 🟥
    Parameter signature (excluding context_id): [('double*', 'out_alpha'), ('double*', 'out_beta'), ('double*', 'out_gamma')]"""
        if self.context_id is None:
            raise ValueError("Invalid context_id for antnet_get_sasa_params")
        rc = lib.antnet_get_sasa_params(self.context_id, out_alpha, out_beta, out_gamma)
        if rc in (0, ERR_SUCCESS):
            return rc
        if rc < 0:
            raise ValueError("antnet_get_sasa_params failed with code {rc}")
        raise RuntimeError("antnet_get_sasa_params returned unexpected {rc}")

    def antnet_set_aco_params(self, alpha, beta, Q, evaporation, num_ants):
        """AUTO-GENERATED thin wrapper for lib.antnet_set_aco_params.
    [File: Unknown] MUST BE IMPLEMENTED 🟥
    Parameter signature (excluding context_id): [('float', 'alpha'), ('float', 'beta'), ('float', 'Q'), ('float', 'evaporation'), ('int', 'num_ants')]"""
        if self.context_id is None:
            raise ValueError("Invalid context_id for antnet_set_aco_params")
        rc = lib.antnet_set_aco_params(self.context_id, alpha, beta, Q, evaporation, num_ants)
        if rc in (0, ERR_SUCCESS):
            return rc
        if rc < 0:
            raise ValueError("antnet_set_aco_params failed with code {rc}")
        raise RuntimeError("antnet_set_aco_params returned unexpected {rc}")

    def antnet_set_sasa_params(self, alpha, beta, gamma):
        """AUTO-GENERATED thin wrapper for lib.antnet_set_sasa_params.
    [File: Unknown] MUST BE IMPLEMENTED 🟥
    Parameter signature (excluding context_id): [('double', 'alpha'), ('double', 'beta'), ('double', 'gamma')]"""
        if self.context_id is None:
            raise ValueError("Invalid context_id for antnet_set_sasa_params")
        rc = lib.antnet_set_sasa_params(self.context_id, alpha, beta, gamma)
        if rc in (0, ERR_SUCCESS):
            return rc
        if rc < 0:
            raise ValueError("antnet_set_sasa_params failed with code {rc}")
        raise RuntimeError("antnet_set_sasa_params returned unexpected {rc}")


# GPU async renderer helpers
_renderer_initialized = False

def init_async_renderer(width: int = 64, height: int = 64) -> None:
    global _renderer_initialized
    if _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_init(width, height)
    if rc != 0:
        raise RuntimeError(f"antnet_renderer_async_init failed with code {rc}")
    _renderer_initialized = True

def shutdown_async_renderer() -> None:
    global _renderer_initialized
    if not _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_shutdown()
    if rc != 0:
        raise RuntimeError(f"antnet_renderer_async_shutdown failed with code {rc}")
    _renderer_initialized = False

def render_heatmap_rgba(
    pts_xy:   list[float],
    strength: list[float],
    width: int,
    height: int
) -> bytes:
    """
    Render a heat-map into an RGBA buffer (width×height×4 bytes).
    """
    init_async_renderer()

    if len(pts_xy) != 2 * len(strength):
        raise ValueError("pts_xy length must be 2×len(strength)")
    if len(pts_xy) % 2:
        raise ValueError("pts_xy length must be even")

    c_pts = ffi.new("float[]", pts_xy)
    c_str = ffi.new("float[]", strength)
    buf   = ffi.new("unsigned char[]", width * height * 4)

    rc = lib.antnet_render_heatmap_rgba(c_pts, c_str, len(strength), buf, width, height)
    if rc != 0:
        raise RuntimeError(f"antnet_render_heatmap_rgba failed with code {rc}")

    return ffi.buffer(buf, width * height * 4)[:]
