# src/python/ffi/backend_api.py
# High-level Python wrapper for the C AntNet backend.
# security/hardening: negative C return code ⇒ ValueError
# unexpected positive non-zero ⇒ RuntimeError

from __future__ import annotations
import os
import sys
import importlib

from consts._generated.error_codes_generated import ERR_SUCCESS
from structs._generated.auto_structs import AppConfig  # This is generated by tools/generate_structs.py

def _ensure_backend_cffi_loaded():
    """
    Attempt to import backend_cffi. If not found, append common build/product
    paths to sys.path and retry exactly once.
    """
    try:
        return importlib.import_module("backend_cffi")
    except ModuleNotFoundError:
        here = os.path.dirname(__file__)
        project_root = os.path.abspath(os.path.join(here, "..", "..", ".."))
        candidates = [
            os.path.join(project_root, "build", "python"),
            os.path.join(project_root, "src", "python"),
            os.path.join(project_root, "src", "python", "ffi"),
        ]
        for path in candidates:
            if path not in sys.path and os.path.isdir(path):
                sys.path.insert(0, path)
        return importlib.import_module("backend_cffi")

_backend = _ensure_backend_cffi_loaded()
ffi, lib = _backend.ffi, _backend.lib  # type: ignore

class AntNetWrapper:
    """
    AntNetWrapper: thin, pythonic façade over the native AntNet API.
    This version allows three ways to initialize:
      (1) from_config="some.ini"
      (2) app_config=some_dict
      (3) node_count=..., min_hops=..., max_hops=...
    If more than one is provided, from_config has highest priority, then app_config,
    then node_count+min_hops+max_hops.
    """

    def __init__(
        self,
        node_count: int | None = None,
        min_hops: int | None = None,
        max_hops: int | None = None,
        from_config: str | None = None,
        app_config: dict | None = None,
    ):
        self.context_id: int | None = None

        # 1) If from_config is given
        if from_config is not None:
            if not isinstance(from_config, str):
                raise ValueError("from_config must be a string path to .ini")
            rc = lib.antnet_init_from_config(from_config.encode("utf-8"))
            if rc < 0:
                raise ValueError(f"antnet_init_from_config failed with code {rc}")
            self.context_id = rc
            return

        # 2) If app_config is given
        if app_config is not None:
            if not isinstance(app_config, dict):
                raise ValueError("app_config must be a dict (likely from TypedDict)")
            node_count = app_config["set_nb_nodes"]
            min_hops = app_config["min_hops"]
            max_hops = app_config["max_hops"]

            rc = lib.antnet_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"antnet_initialize failed with code {rc}")
            self.context_id = rc
            return

        # 3) node_count + min_hops + max_hops
        if node_count is not None and min_hops is not None and max_hops is not None:
            rc = lib.antnet_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"antnet_initialize failed with code {rc}")
            self.context_id = rc
            return

        raise ValueError(
            "AntNetWrapper requires either from_config=..., or app_config=..., "
            "or node_count/min_hops/max_hops."
        )

    @classmethod
    def from_config(cls, path: str) -> AntNetWrapper:
        return cls(from_config=path)

    def get_config(self) -> AppConfig:
        """
        get_config: thread-safe retrieval of the backend AppConfig structure.
        """
        if self.context_id is None:
            raise ValueError("No valid context_id to get config.")
        config_struct = ffi.new("AppConfig*")
        rc = lib.antnet_get_config(self.context_id, config_struct)
        if rc != 0:
            raise ValueError(f"get_config failed with code {rc}")

        return {
            "nb_swarms": config_struct.nb_swarms,
            "set_nb_nodes": config_struct.set_nb_nodes,
            "min_hops": config_struct.min_hops,
            "max_hops": config_struct.max_hops,
            "default_delay": config_struct.default_delay,
            "death_delay": config_struct.death_delay,
            "under_attack_id": config_struct.under_attack_id,
            "attack_started": bool(config_struct.attack_started),
            "simulate_ddos": bool(config_struct.simulate_ddos),
            "show_random_performance": bool(config_struct.show_random_performance),
            "show_brute_performance": bool(config_struct.show_brute_performance),
        }

    def run_iteration(self) -> None:
        rc = lib.antnet_run_iteration(self.context_id)
        if rc == ERR_SUCCESS:
            return
        elif rc < 0:
            raise ValueError(f"run_iteration failed with code {rc}")
        else:
            raise RuntimeError(f"run_iteration returned unexpected code {rc}")

    def get_best_path_struct(self):
        """
        Returns a dict with "nodes" (list[int]) and "total_latency" (int).
        """
        max_nodes = 1024
        nodes_buf = ffi.new("int[]", max_nodes)
        len_ptr = ffi.new("int*")
        lat_ptr = ffi.new("int*")

        rc = lib.antnet_get_best_path(self.context_id, nodes_buf, max_nodes, len_ptr, lat_ptr)
        if rc == ERR_SUCCESS:
            return {
                "nodes": [nodes_buf[i] for i in range(len_ptr[0])],
                "total_latency": lat_ptr[0],
            }
        elif rc < 0:
            raise ValueError(f"get_best_path failed with code {rc}")
        else:
            raise RuntimeError(f"get_best_path returned unexpected code {rc}")

    def update_topology(self, nodes, edges):
        """
        Replaces node/edge arrays in the backend.
        NodeData: node_id (int >= 0), delay_ms (int >= 0).
        EdgeData: from_id (int >= 0), to_id (int >= 0).

        Raises ValueError on invalid arguments or negative return code from C.
        Raises RuntimeError if C returns unexpected positive code.
        """
        if self.context_id is None:
            raise ValueError("Invalid context_id")

        n = len(nodes)
        e = len(edges)
        if n == 0 or e == 0:
            raise ValueError("Empty node or edge list")

        node_arr = ffi.new("NodeData[]", n)
        edge_arr = ffi.new("EdgeData[]", e)

        for i, nd in enumerate(nodes):
            node_id = nd.get("node_id")
            delay_ms = nd.get("delay_ms")
            if not isinstance(node_id, int) or node_id < 0:
                raise ValueError(f"Invalid node_id: {node_id}")
            if not isinstance(delay_ms, int) or delay_ms < 0:
                raise ValueError(f"Invalid delay_ms: {delay_ms}")
            node_arr[i].node_id = node_id
            node_arr[i].delay_ms = delay_ms
            node_arr[i].x = 0.0  # not used in backend
            node_arr[i].y = 0.0
            node_arr[i].radius = 0

        for j, ed in enumerate(edges):
            from_id = ed.get("from_id")
            to_id   = ed.get("to_id")
            if not isinstance(from_id, int) or from_id < 0:
                raise ValueError(f"Invalid from_id: {from_id}")
            if not isinstance(to_id, int) or to_id < 0:
                raise ValueError(f"Invalid to_id: {to_id}")
            edge_arr[j].from_id = from_id
            edge_arr[j].to_id   = to_id

        rc = lib.antnet_update_topology(self.context_id, node_arr, n, edge_arr, e)
        if rc == ERR_SUCCESS:
            return
        elif rc < 0:
            raise ValueError(f"update_topology failed with code {rc}")
        else:
            raise RuntimeError(f"update_topology returned unexpected code {rc}")

    def run_all_solvers(self):
        """
        Runs the ACO, random, and brute force solvers in a single call,
        returning a dictionary with results for each approach.
        """
        max_nodes = 1024
        a_nodes = ffi.new("int[]", max_nodes)
        r_nodes = ffi.new("int[]", max_nodes)
        b_nodes = ffi.new("int[]", max_nodes)

        a_len = ffi.new("int*")
        r_len = ffi.new("int*")
        b_len = ffi.new("int*")
        a_lat = ffi.new("int*")
        r_lat = ffi.new("int*")
        b_lat = ffi.new("int*")

        rc = lib.antnet_run_all_solvers(
            self.context_id,
            a_nodes, max_nodes, a_len, a_lat,
            r_nodes, max_nodes, r_len, r_lat,
            b_nodes, max_nodes, b_len, b_lat
        )
        if rc == ERR_SUCCESS:
            return {
                "aco": {
                    "nodes": [a_nodes[i] for i in range(a_len[0])],
                    "total_latency": a_lat[0]
                },
                "random": {
                    "nodes": [r_nodes[i] for i in range(r_len[0])],
                    "total_latency": r_lat[0]
                },
                "brute": {
                    "nodes": [b_nodes[i] for i in range(b_len[0])],
                    "total_latency": b_lat[0]
                },
            }
        elif rc < 0:
            raise ValueError(f"run_all_solvers failed with code {rc}")
        else:
            raise RuntimeError(f"run_all_solvers returned unexpected code {rc}")

    def get_pheromone_matrix(self) -> list[float]:
        """
        get_pheromone_matrix: retrieves the entire pheromone matrix as a flat float list.
        size = n*n, where n = aco_v1.pheromone_size in C.
        Raises ValueError if an error occurs (negative return code).
        """
        if self.context_id is None:
            raise ValueError("No valid context_id to get pheromone matrix.")
        size = 1024 * 1024  # safe upper bound
        buf = ffi.new("float[]", size)
        rc = lib.antnet_get_pheromone_matrix(self.context_id, buf, size)
        if rc < 0:
            raise ValueError(f"get_pheromone_matrix failed with code {rc}")
        return [buf[i] for i in range(rc)]

    def shutdown(self):
        if self.context_id is not None:
            rc = lib.antnet_shutdown(self.context_id)
            if rc == ERR_SUCCESS:
                self.context_id = None
            elif rc < 0:
                raise ValueError(f"antnet_shutdown failed with code {rc}")
            else:
                raise RuntimeError(f"antnet_shutdown returned unexpected code {rc}")

    def __del__(self):
        """
        Ensure we release the context when this object is GCed.
        """
        try:
            self.shutdown()
        except:
            pass


    # (all antnet_* functions accounted for in manual code)


# Global state for the async renderer. This ensures we init exactly once.
_renderer_initialized = False

def init_async_renderer(width: int = 64, height: int = 64) -> None:
    """
    Initializes the persistent background renderer.
    Safe to call multiple times; the second time is no-op.
    """
    global _renderer_initialized
    if _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_init(width, height)
    if rc == 0:
        _renderer_initialized = True
    else:
        raise RuntimeError(f"init_async_renderer failed with code {rc}")

def shutdown_async_renderer() -> None:
    """
    Stops the background renderer thread. Safe to call more than once.
    """
    global _renderer_initialized
    if not _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_shutdown()
    if rc == 0:
        _renderer_initialized = False
    else:
        raise RuntimeError(f"shutdown_async_renderer failed with code {rc}")

def render_heatmap_rgba(
    pts_xy: list[float],
    strength: list[float],
    width: int,
    height: int
) -> bytes:
    """
    Renders a heatmap from a point cloud and strength values using the GPU (OpenGL ES + EGL).
    This function is fully decoupled from AntNetWrapper and may be called from any thread.

    Uses a persistent background thread to avoid interfering with Qt.
    """
    # Ensure the async renderer is started
    init_async_renderer()

    if len(pts_xy) % 2 != 0:
        raise ValueError("pts_xy must be a flat list of x,y pairs (even length)")

    n = len(strength)
    if len(pts_xy) != 2 * n:
        raise ValueError("length mismatch: len(pts_xy) must be 2×len(strength)")

    c_pts = ffi.new("float[]", pts_xy)
    c_str = ffi.new("float[]", strength)
    c_buf = ffi.new("unsigned char[]", width * height * 4)

    rc = lib.antnet_render_heatmap_rgba(c_pts, c_str, n, c_buf, width, height)
    if rc != ERR_SUCCESS:
        raise RuntimeError(f"heatmap render failed with code {rc}")

    return ffi.buffer(c_buf, width * height * 4)[:]
