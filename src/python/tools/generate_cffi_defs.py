#!/usr/bin/env python3
# src/python/ffi/generate_cffi_defs.py
"""
Generate src/python/ffi/cdef_string.py from pre-processed .i files.

Strategy
--------
• If a typedef embeds the full body of a struct/union/enum, emit
    typedef struct { … } Alias;
  and mark the tag as handled.
• Otherwise (no such typedef), emit a normal
    struct tag { … };
  line.
• Forward declarations are ignored.
• Function prototypes are unique.
"""

from __future__ import annotations
import argparse
from pathlib import Path
from typing import List, Set

from pycparser import c_ast, c_generator, parse_file


class CDefExtractor(c_ast.NodeVisitor):
    def __init__(self) -> None:
        super().__init__()
        self.gen = c_generator.CGenerator()
        self.emitted_tags: Set[str] = set()
        self.lines: List[str] = []
        self.funcs: List[str] = []

    # -------------------------------------------------------- typedef handler
    def visit_Typedef(self, node: c_ast.Typedef) -> None:
        # Check if typedef embeds a struct/union/enum *with a body*.
        if isinstance(node.type, c_ast.TypeDecl):
            base = node.type.type
            if isinstance(base, (c_ast.Struct, c_ast.Union, c_ast.Enum)):
                tag = base.name or ""
                if base.decls:                         # body present
                    if tag in self.emitted_tags:
                        return                          # already handled
                    # Build anonymous-body typedef:  typedef struct { … } Alias;
                    body = "\n".join(
                        f"    {self.gen.visit(d)};" for d in base.decls
                    )
                    self.lines.append(
                        f"typedef struct {{\n{body}\n}} {node.name};"
                    )
                    if tag:
                        self.emitted_tags.add(tag)
                    return                              # do not descend
                else:
                    # typedef to a tag only (no body)
                    if tag and tag not in self.emitted_tags:
                        # struct body will appear elsewhere; record alias
                        typedef_line = self.gen.visit(node) + ";"
                        self.lines.append(typedef_line)
                    return
        self.generic_visit(node)

    # ----------------------------------------------------------- struct body
    def visit_Struct(self, node: c_ast.Struct) -> None:
        tag = node.name or ""
        if not node.decls:               # forward decl -> ignore
            return
        if tag in self.emitted_tags:     # already emitted via typedef
            return
        body = "\n".join(
            f"    {self.gen.visit(d)};" for d in node.decls
        )
        self.lines.append(f"struct {tag} {{\n{body}\n}};")
        if tag:
            self.emitted_tags.add(tag)
        # visit nested declarations
        for decl in node.decls:
            self.visit(decl)

    # ------------------------------------------------------------ functions
    def visit_Decl(self, node: c_ast.Decl) -> None:
        if isinstance(node.type, c_ast.FuncDecl):
            proto = self.gen.visit(node) + ";"
            if proto not in self.funcs:
                self.funcs.append(proto)
        self.generic_visit(node)


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--preprocessed", required=True)
    ap.add_argument("--output", required=True)
    ns = ap.parse_args()

    extractor = CDefExtractor()

    cpp_args = [
        "-D__attribute__(...)=", "-D__attribute__=",
        "-D__extension__=", "-D__inline__=",
        "-D__volatile__=", "-D__asm__=",
        "-D__restrict=", "-D__restrict__=",
        "-D__builtin_va_list=int", "-D__GNUC__=4",
        "-Dbool=_Bool", "-Dtrue=1", "-Dfalse=0",
    ]

    for i_file in sorted(Path(ns.preprocessed).glob("*.i")):
        ast = parse_file(str(i_file), use_cpp=True, cpp_args=cpp_args)
        extractor.visit(ast)

    chunks: List[str] = []
    if extractor.lines:
        chunks.append("\n".join(extractor.lines))
    if extractor.funcs:
        if chunks:
            chunks.append("")
        chunks.append("\n".join(extractor.funcs))

    (Path(ns.output).parent).mkdir(parents=True, exist_ok=True)
    Path(ns.output).write_text(
        "# Auto-generated by generate_cffi_defs.py – DO NOT EDIT\n"
        "CDEF_SOURCE = '''\\\n"
        + "\n\n".join(chunks).rstrip()
        + "\n'''",
        encoding="utf-8",
    )

    print(f"Wrote {len(extractor.lines)} struct/typedef lines and "
          f"{len(extractor.funcs)} function(s) to {ns.output}")


if __name__ == "__main__":
    main()
