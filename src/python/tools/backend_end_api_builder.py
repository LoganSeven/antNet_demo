#!/usr/bin/env python3
# Relative Path: src/python/tools/backend_end_api_builder.py
#
# backend_end_api_builder.py
# Re-generates src/python/ffi/backend_api.py every build.
# The script merges TEMPLATE_BEFORE (manual code) with TEMPLATE_AFTER (utility helpers),
# auto-inserting thin wrappers for each lib.antnet_* function discovered in cdef_string.py
# but not already referenced in TEMPLATE_BEFORE.
#
# The result is a unified Python file that offers a high-level interface to the C AntNet backend.
# The script also writes a brief report to build/api_autogen_report.txt.

from __future__ import annotations
import ast
import importlib.util
import re
import sys
from pathlib import Path
from textwrap import indent

# Paths
ROOT = Path(__file__).resolve().parents[3]
CDEF_PY = ROOT / "src/python/ffi/cdef_string.py"
OUTPUT = ROOT / "src/python/ffi/backend_api.py"
REPORT = ROOT / "build/api_autogen_report.txt"

# Templates
TEMPLATE_BEFORE = r'''# src/python/ffi/backend_api.py
# High-level Python wrapper for the C AntNet backend.
# security/hardening: negative C return code ⇒ ValueError
# unexpected positive non-zero ⇒ RuntimeError

from __future__ import annotations
import os
import sys
import importlib

from consts._generated.error_codes_generated import ERR_SUCCESS
from structs._generated.auto_structs import AppConfig  # generated by tools/generate_structs.py

# ----------------------------------------------------------------------
#  Dynamic import of backend_cffi (the CFFI-generated glue module)
# ----------------------------------------------------------------------
def _ensure_backend_cffi_loaded():
    """
    Attempt to import backend_cffi.
    If not found, prepend common build paths to sys.path and retry exactly once.
    """
    try:
        return importlib.import_module("backend_cffi")
    except ModuleNotFoundError:
        here = os.path.dirname(__file__)
        root = os.path.abspath(os.path.join(here, "..", "..", ".."))
        for p in (
            os.path.join(root, "build", "python"),
            os.path.join(root, "src",  "python"),
            os.path.join(root, "src",  "python", "ffi"),
        ):
            if p not in sys.path and os.path.isdir(p):
                sys.path.insert(0, p)
        return importlib.import_module("backend_cffi")

_backend = _ensure_backend_cffi_loaded()
ffi, lib = _backend.ffi, _backend.lib  # type: ignore

# ----------------------------------------------------------------------
#  AntNetWrapper – thin, pythonic façade over the native API
# ----------------------------------------------------------------------
class AntNetWrapper:
    """
    Wrapper supports three constructors:
        AntNetWrapper.from_config("file.ini")
        AntNetWrapper(app_config={…})
        AntNetWrapper(node_count, min_hops, max_hops)
    """

    # ─────────────────────────────── ctor ────────────────────────────
    def __init__(
        self,
        node_count: int | None = None,
        min_hops:   int | None = None,
        max_hops:   int | None = None,
        from_config: str | None = None,
        app_config:  dict | None = None,
    ):
        self.context_id: int | None = None

        # 1) ini-file
        if from_config is not None:
            if not isinstance(from_config, str):
                raise ValueError("from_config must be a str path to .ini")
            rc = lib.antnet_init_from_config(from_config.encode("utf-8"))
            if rc < 0:
                raise ValueError(f"antnet_init_from_config failed with code {rc}")
            self.context_id = rc
            return

        # 2) dict-based config
        if app_config is not None:
            if not isinstance(app_config, dict):
                raise ValueError("app_config must be a dict")
            node_count = app_config["set_nb_nodes"]
            min_hops   = app_config["min_hops"]
            max_hops   = app_config["max_hops"]

        # 3) raw numbers
        if node_count is not None and min_hops is not None and max_hops is not None:
            rc = lib.antnet_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"antnet_initialize failed with code {rc}")
            self.context_id = rc
            return

        raise ValueError(
            "Need either from_config=…, or app_config=…, "
            "or node_count/min_hops/max_hops."
        )

    # convenience
    @classmethod
    def from_config(cls, path: str) -> "AntNetWrapper":
        return cls(from_config=path)

    # ─────────────────────── configuration read ─────────────────────
    def get_config(self) -> AppConfig:
        if self.context_id is None:
            raise ValueError("No valid context_id")
        cfg_ptr = ffi.new("AppConfig*")
        rc = lib.antnet_get_config(self.context_id, cfg_ptr)
        if rc != 0:
            raise ValueError(f"antnet_get_config failed with code {rc}")
        return {
            "nb_swarms":              cfg_ptr.nb_swarms,
            "set_nb_nodes":           cfg_ptr.set_nb_nodes,
            "min_hops":               cfg_ptr.min_hops,
            "max_hops":               cfg_ptr.max_hops,
            "default_delay":          cfg_ptr.default_delay,
            "death_delay":            cfg_ptr.death_delay,
            "under_attack_id":        cfg_ptr.under_attack_id,
            "attack_started":         bool(cfg_ptr.attack_started),
            "simulate_ddos":          bool(cfg_ptr.simulate_ddos),
            "show_random_performance": bool(cfg_ptr.show_random_performance),
            "show_brute_performance":  bool(cfg_ptr.show_brute_performance),
        }

    # ────────────────────────── iteration ───────────────────────────
    def run_iteration(self) -> None:
        rc = lib.antnet_run_iteration(self.context_id)
        if rc == ERR_SUCCESS:
            return
        if rc < 0:
            raise ValueError(f"run_iteration failed with code {rc}")
        raise RuntimeError(f"run_iteration returned unexpected {rc}")

    # ─────────────────────── best-path helper ───────────────────────
    def get_best_path_struct(self):
        max_nodes = 1024
        nodes_buf = ffi.new("int[]", max_nodes)
        len_ptr   = ffi.new("int*")
        lat_ptr   = ffi.new("int*")

        rc = lib.antnet_get_best_path(self.context_id, nodes_buf, max_nodes, len_ptr, lat_ptr)
        if rc != 0:
            raise ValueError(f"get_best_path failed with code {rc}")
        return {
            "nodes": [nodes_buf[i] for i in range(len_ptr[0])],
            "total_latency": lat_ptr[0],
        }

    # ───────────────────── topology replacement ─────────────────────
    def update_topology(self, nodes: list[dict], edges: list[dict]) -> None:
        """
        Push a new node/edge array into the backend.
        Each node → {"node_id": int >=0, "delay_ms": int >=0}
        Each edge → {"from_id": int >=0, "to_id":   int >=0}
        """
        if self.context_id is None:
            raise ValueError("Invalid context_id")

        n, e = len(nodes), len(edges)
        if n == 0 or e == 0:
            raise ValueError("Empty node or edge list")

        node_arr = ffi.new("NodeData[]", n)
        edge_arr = ffi.new("EdgeData[]", e)

        for i, nd in enumerate(nodes):
            node_id  = nd.get("node_id")
            delay_ms = nd.get("delay_ms")
            if not isinstance(node_id, int) or node_id < 0:
                raise ValueError(f"Invalid node_id: {node_id}")
            if not isinstance(delay_ms, int) or delay_ms < 0:
                raise ValueError(f"Invalid delay_ms: {delay_ms}")
            node_arr[i].node_id  = node_id
            node_arr[i].delay_ms = delay_ms
            node_arr[i].x = node_arr[i].y = 0.0
            node_arr[i].radius = 0

        for j, ed in enumerate(edges):
            from_id = ed.get("from_id")
            to_id   = ed.get("to_id")
            if not isinstance(from_id, int) or from_id < 0:
                raise ValueError(f"Invalid from_id: {from_id}")
            if not isinstance(to_id, int) or to_id < 0:
                raise ValueError(f"Invalid to_id: {to_id}")
            edge_arr[j].from_id = from_id
            edge_arr[j].to_id   = to_id

        rc = lib.antnet_update_topology(self.context_id, node_arr, n, edge_arr, e)
        if rc == 0:
            return
        if rc < 0:
            raise ValueError(f"update_topology failed with code {rc}")
        raise RuntimeError(f"update_topology returned unexpected {rc}")

    # ───────────────────── run all solvers in C ─────────────────────
    def run_all_solvers(self):
        max_nodes = 1024
        a_nodes = ffi.new("int[]", max_nodes)
        r_nodes = ffi.new("int[]", max_nodes)
        b_nodes = ffi.new("int[]", max_nodes)

        a_len = ffi.new("int*"); r_len = ffi.new("int*"); b_len = ffi.new("int*")
        a_lat = ffi.new("int*"); r_lat = ffi.new("int*"); b_lat = ffi.new("int*")

        rc = lib.antnet_run_all_solvers(
            self.context_id,
            a_nodes, max_nodes, a_len, a_lat,
            r_nodes, max_nodes, r_len, r_lat,
            b_nodes, max_nodes, b_len, b_lat
        )
        if rc != 0:
            raise ValueError(f"run_all_solvers failed with code {rc}")

        return {
            "aco": {
                "nodes": [a_nodes[i] for i in range(a_len[0])],
                "total_latency": a_lat[0],
            },
            "random": {
                "nodes": [r_nodes[i] for i in range(r_len[0])],
                "total_latency": r_lat[0],
            },
            "brute": {
                "nodes": [b_nodes[i] for i in range(b_len[0])],
                "total_latency": b_lat[0],
            },
        }

    # ───────────────────── pheromone matrix read ────────────────────
    def get_pheromone_matrix(self) -> list[float]:
        if self.context_id is None:
            raise ValueError("Invalid context_id")
        max_floats = 1024 * 1024
        buf = ffi.new("float[]", max_floats)
        rc = lib.antnet_get_pheromone_matrix(self.context_id, buf, max_floats)
        if rc < 0:
            raise ValueError(f"get_pheromone_matrix failed with code {rc}")
        return [buf[i] for i in range(rc)]

    # ─────────────────────────── ranking ────────────────────────────
    def get_algo_ranking(self) -> list[dict]:
        if self.context_id is None:
            raise ValueError("Invalid context_id")
        max_algs = 8
        rank_arr = ffi.new("RankingEntry[]", max_algs)
        rc = lib.antnet_get_algo_ranking(self.context_id, rank_arr, max_algs)
        if rc < 0:
            raise ValueError(f"get_algo_ranking failed with code {rc}")
        result: list[dict] = []
        for i in range(rc):
            name = ffi.string(rank_arr[i].name).decode("utf-8", "ignore")
            result.append({
                "name":       name,
                "score":      rank_arr[i].score,
                "latency_ms": rank_arr[i].latency_ms,
            })
        return result

    # ───────────────────────── shutdown ─────────────────────────────
    def shutdown(self) -> None:
        if self.context_id is None:
            return
        rc = lib.antnet_shutdown(self.context_id)
        if rc == 0:
            self.context_id = None
            return
        if rc < 0:
            raise ValueError(f"antnet_shutdown failed with code {rc}")
        raise RuntimeError(f"antnet_shutdown returned unexpected {rc}")

    def __del__(self):
        try:
            self.shutdown()
        except Exception:
            pass
'''

TEMPLATE_AFTER = r'''
# GPU async renderer helpers
_renderer_initialized = False

def init_async_renderer(width: int = 64, height: int = 64) -> None:
    global _renderer_initialized
    if _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_init(width, height)
    if rc != 0:
        raise RuntimeError(f"antnet_renderer_async_init failed with code {rc}")
    _renderer_initialized = True

def shutdown_async_renderer() -> None:
    global _renderer_initialized
    if not _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_shutdown()
    if rc != 0:
        raise RuntimeError(f"antnet_renderer_async_shutdown failed with code {rc}")
    _renderer_initialized = False

def render_heatmap_rgba(
    pts_xy:   list[float],
    strength: list[float],
    width: int,
    height: int
) -> bytes:
    """
    Render a heat-map into an RGBA buffer (width×height×4 bytes).
    """
    init_async_renderer()

    if len(pts_xy) != 2 * len(strength):
        raise ValueError("pts_xy length must be 2×len(strength)")
    if len(pts_xy) % 2:
        raise ValueError("pts_xy length must be even")

    c_pts = ffi.new("float[]", pts_xy)
    c_str = ffi.new("float[]", strength)
    buf   = ffi.new("unsigned char[]", width * height * 4)

    rc = lib.antnet_render_heatmap_rgba(c_pts, c_str, len(strength), buf, width, height)
    if rc != 0:
        raise RuntimeError(f"antnet_render_heatmap_rgba failed with code {rc}")

    return ffi.buffer(buf, width * height * 4)[:]
'''

###############################################################################
# Enhanced function signature parsing
###############################################################################
FUNC_SIG_RE = re.compile(
    r"""
    ^\s*
    (?P<return_type>[\w\s\*\_]+)     # e.g. int, float*, etc
    \s+
    (?P<fn_name>antnet_\w+)          # e.g. antnet_run_iteration
    \s*\(
    (?P<params>[^)]*)                # everything until closing parenthesis
    \)
""",
    re.MULTILINE | re.VERBOSE
)

# Optional: map function names to .c files for docstring references
FUNCTION_FILE_MAP = {
    "antnet_initialize":             "backend_init.c",
    "antnet_shutdown":               "backend_init.c",
    "antnet_run_iteration":          "backend_solvers.c",
    "antnet_get_best_path":          "backend_solvers.c",
    "antnet_run_all_solvers":        "backend_solvers.c",
    "antnet_get_pheromone_matrix":   "backend_params.c",
    "antnet_get_aco_params":         "backend_params.c",
    "antnet_set_aco_params":         "backend_params.c",
    # ... etc
}

def load_cdefs_with_signatures() -> list[dict]:
    """
    Loads cdef_string.py, extracts function signatures for antnet_*.
    Returns a list of dicts sorted by fn_name:
    [
      {
        'return_type': 'int',
        'fn_name': 'antnet_run_iteration',
        'params': 'int context_id, float alpha'
      },
      ...
    ]
    """
    spec = importlib.util.spec_from_file_location("_cdef", CDEF_PY)
    mod = importlib.util.module_from_spec(spec)  # type: ignore
    spec.loader.exec_module(mod)                 # type: ignore

    text = mod.CDEF_SOURCE  # type: ignore
    result = []
    for match in FUNC_SIG_RE.finditer(text):
        result.append({
            "return_type": match.group("return_type").strip(),
            "fn_name":     match.group("fn_name").strip(),
            "params":      match.group("params").strip(),
        })
    return sorted(result, key=lambda x: x["fn_name"])


def parse_params(param_string: str) -> list[tuple[str, str]]:
    """
    Splits the comma-separated param string into (type, varname).
    Example: "float *out_alpha, int *out_num_ants"
       => [("float*", "out_alpha"), ("int*", "out_num_ants")]
    We remove "context_id" from the final signature later.
    """
    if not param_string.strip():
        return []
    params = []
    for raw in param_string.split(","):
        raw = raw.strip()
        # e.g. "float *out_alpha"
        # 1) split by whitespace from the right to get the var name
        pieces = raw.rsplit(None, 1)
        if len(pieces) < 2:
            continue
        ptype, pname = pieces
        ptype = ptype.strip()

        # If the name has leading '*' or other pointer symbols, merge them into ptype
        # Example: "out_alpha" => "out_alpha", but "*out_alpha" => "out_alpha" with ptype containing one more '*'
        while pname.startswith("*"):
            ptype += "*"
            pname = pname[1:]

        # Also handle if user wrote "float** out_alpha"
        # The above approach will keep the initial star in ptype, so "float*" becomes "float**", etc.

        # unify any double space
        ptype = ptype.replace("  ", " ")

        params.append((ptype, pname))
    return params


def detect_existing_wrappers() -> set[str]:
    """
    Parses the existing backend_api.py to find which antnet_* functions
    are already wrapped in manual code or previously generated stubs.
    """
    if not OUTPUT.exists():
        return set()
    source_text = OUTPUT.read_text(encoding="utf-8")
    try:
        tree = ast.parse(source_text)
    except SyntaxError:
        # If there's a partial or invalid file, we'll treat it as no wrappers found
        return set()
    return {
        node.func.attr
        for node in ast.walk(tree)
        if isinstance(node, ast.Call)
        and isinstance(node.func, ast.Attribute)
        and node.func.attr.startswith("antnet_")
    }


def generate_wrapper(fn_dict: dict) -> str:
    """
    Generates a Python wrapper for a single antnet_* function.
    Excludes context_id from the param list. Adds docstring with big red marker.
    """
    fn_name = fn_dict["fn_name"]
    raw_params = parse_params(fn_dict["params"])

    # Exclude "context_id"
    actual_params = [(t, n) for (t, n) in raw_params if n != "context_id"]

    # Build a Python param list (just names, ignoring the C type)
    py_params_str = ", ".join(n for (t, n) in actual_params)

    # Potential c file
    c_file = FUNCTION_FILE_MAP.get(fn_name, "Unknown")
    big_red = "🟥"

    doc = (
        f"AUTO-GENERATED thin wrapper for lib.{fn_name}.\n"
        f"[File: {c_file}] MUST BE IMPLEMENTED {big_red}\n"
        f"Parameter signature (excluding context_id): {actual_params}"
    )

    # build final call
    call_params = ", ".join(["self.context_id"] + [n for (t, n) in actual_params])

    code = f"""def {fn_name}(self, {py_params_str}):
    \"\"\"{doc}\"\"\"
    if self.context_id is None:
        raise ValueError("Invalid context_id for {fn_name}")
    rc = lib.{fn_name}({call_params})
    if rc in (0, ERR_SUCCESS):
        return rc
    if rc < 0:
        raise ValueError("{fn_name} failed with code {{rc}}")
    raise RuntimeError("{fn_name} returned unexpected {{rc}}")"""
    return indent(code, "    ")


def main() -> None:
    # Load all function signatures
    all_func_dicts = load_cdefs_with_signatures()

    # Which ones are already implemented?
    implemented = detect_existing_wrappers()

    # Build list of missing
    missing_dicts = [d for d in all_func_dicts if d["fn_name"] not in implemented]

    if missing_dicts:
        auto_block = "\n\n".join(generate_wrapper(d) for d in missing_dicts)
    else:
        auto_block = "    # (all antnet_* functions accounted for in manual code)"

    OUTPUT.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT, "w", encoding="utf-8") as fh:
        fh.write(TEMPLATE_BEFORE + "\n\n" + auto_block + "\n\n" + TEMPLATE_AFTER)

    REPORT.parent.mkdir(parents=True, exist_ok=True)
    with open(REPORT, "w", encoding="utf-8") as rep:
        rep.write(
            f"Total antnet_* in CDEF   : {len(all_func_dicts)}\n"
            f"Already implemented      : {len(implemented)}\n"
            f"Wrappers auto-generated  : {len(missing_dicts)}\n"
        )

    print(f"✅ backend_api.py regenerated ({len(missing_dicts)} auto-wrapper(s) added).")


if __name__ == "__main__":
    main()
