#!/usr/bin/env python3
# src/python/ffi/backend_end_api_builder.py

from __future__ import annotations

import ast
import importlib.util
import re
import sys
from pathlib import Path
from textwrap import indent

# ────────────────────────────── Paths ──────────────────────────────
ROOT     = Path(__file__).resolve().parents[3]
CDEF_PY  = ROOT / "src/python/ffi/cdef_string.py"
OUTPUT   = ROOT / "src/python/ffi/backend_api.py"
REPORT   = ROOT / "build/api_autogen_report.txt"

# ─────────────────────────── TEMPLATES ─────────────────────────────

# This is the core “manual” code you provided. It's split into BEFORE and AFTER 
# so that we can insert auto-generated stubs if new C functions appear:
TEMPLATE_BEFORE = r'''# src/python/ffi/backend_api.py
# High-level Python wrapper for the C AntNet backend.
# security/hardening: negative C return code ⇒ ValueError
# unexpected positive non-zero ⇒ RuntimeError

from __future__ import annotations
import os
import sys
import importlib

from consts._generated.error_codes_generated import ERR_SUCCESS
from structs._generated.auto_structs import AppConfig  # This is generated by tools/generate_structs.py

def _ensure_backend_cffi_loaded():
    """
    Attempt to import backend_cffi. If not found, append common build/product
    paths to sys.path and retry exactly once.
    """
    try:
        return importlib.import_module("backend_cffi")
    except ModuleNotFoundError:
        here = os.path.dirname(__file__)
        project_root = os.path.abspath(os.path.join(here, "..", "..", ".."))
        candidates = [
            os.path.join(project_root, "build", "python"),
            os.path.join(project_root, "src", "python"),
            os.path.join(project_root, "src", "python", "ffi"),
        ]
        for path in candidates:
            if path not in sys.path and os.path.isdir(path):
                sys.path.insert(0, path)
        return importlib.import_module("backend_cffi")

_backend = _ensure_backend_cffi_loaded()
ffi, lib = _backend.ffi, _backend.lib  # type: ignore

class AntNetWrapper:
    """
    AntNetWrapper: thin, pythonic façade over the native AntNet API.
    This version allows three ways to initialize:
      (1) from_config="some.ini"
      (2) app_config=some_dict
      (3) node_count=..., min_hops=..., max_hops=...
    If more than one is provided, from_config has highest priority, then app_config,
    then node_count+min_hops+max_hops.
    """

    def __init__(
        self,
        node_count: int | None = None,
        min_hops: int | None = None,
        max_hops: int | None = None,
        from_config: str | None = None,
        app_config: dict | None = None,
    ):
        self.context_id: int | None = None

        # 1) If from_config is given
        if from_config is not None:
            if not isinstance(from_config, str):
                raise ValueError("from_config must be a string path to .ini")
            rc = lib.antnet_init_from_config(from_config.encode("utf-8"))
            if rc < 0:
                raise ValueError(f"antnet_init_from_config failed with code {rc}")
            self.context_id = rc
            return

        # 2) If app_config is given
        if app_config is not None:
            if not isinstance(app_config, dict):
                raise ValueError("app_config must be a dict (likely from TypedDict)")
            node_count = app_config["set_nb_nodes"]
            min_hops = app_config["min_hops"]
            max_hops = app_config["max_hops"]

            rc = lib.antnet_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"antnet_initialize failed with code {rc}")
            self.context_id = rc
            return

        # 3) node_count + min_hops + max_hops
        if node_count is not None and min_hops is not None and max_hops is not None:
            rc = lib.antnet_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"antnet_initialize failed with code {rc}")
            self.context_id = rc
            return

        raise ValueError(
            "AntNetWrapper requires either from_config=..., or app_config=..., "
            "or node_count/min_hops/max_hops."
        )

    @classmethod
    def from_config(cls, path: str) -> AntNetWrapper:
        return cls(from_config=path)

    def get_config(self) -> AppConfig:
        """
        get_config: thread-safe retrieval of the backend AppConfig structure.
        """
        if self.context_id is None:
            raise ValueError("No valid context_id to get config.")
        config_struct = ffi.new("AppConfig*")
        rc = lib.antnet_get_config(self.context_id, config_struct)
        if rc != 0:
            raise ValueError(f"get_config failed with code {rc}")

        return {
            "nb_swarms": config_struct.nb_swarms,
            "set_nb_nodes": config_struct.set_nb_nodes,
            "min_hops": config_struct.min_hops,
            "max_hops": config_struct.max_hops,
            "default_delay": config_struct.default_delay,
            "death_delay": config_struct.death_delay,
            "under_attack_id": config_struct.under_attack_id,
            "attack_started": bool(config_struct.attack_started),
            "simulate_ddos": bool(config_struct.simulate_ddos),
            "show_random_performance": bool(config_struct.show_random_performance),
            "show_brute_performance": bool(config_struct.show_brute_performance),
        }

    def run_iteration(self) -> None:
        rc = lib.antnet_run_iteration(self.context_id)
        if rc == ERR_SUCCESS:
            return
        elif rc < 0:
            raise ValueError(f"run_iteration failed with code {rc}")
        else:
            raise RuntimeError(f"run_iteration returned unexpected code {rc}")

    def get_best_path_struct(self):
        """
        Returns a dict with "nodes" (list[int]) and "total_latency" (int).
        """
        max_nodes = 1024
        nodes_buf = ffi.new("int[]", max_nodes)
        len_ptr = ffi.new("int*")
        lat_ptr = ffi.new("int*")

        rc = lib.antnet_get_best_path(self.context_id, nodes_buf, max_nodes, len_ptr, lat_ptr)
        if rc == ERR_SUCCESS:
            return {
                "nodes": [nodes_buf[i] for i in range(len_ptr[0])],
                "total_latency": lat_ptr[0],
            }
        elif rc < 0:
            raise ValueError(f"get_best_path failed with code {rc}")
        else:
            raise RuntimeError(f"get_best_path returned unexpected code {rc}")

    def update_topology(self, nodes, edges):
        """
        Replaces node/edge arrays in the backend.
        NodeData: node_id (int >= 0), delay_ms (int >= 0).
        EdgeData: from_id (int >= 0), to_id (int >= 0).

        Raises ValueError on invalid arguments or negative return code from C.
        Raises RuntimeError if C returns unexpected positive code.
        """
        if self.context_id is None:
            raise ValueError("Invalid context_id")

        n = len(nodes)
        e = len(edges)
        if n == 0 or e == 0:
            raise ValueError("Empty node or edge list")

        node_arr = ffi.new("NodeData[]", n)
        edge_arr = ffi.new("EdgeData[]", e)

        for i, nd in enumerate(nodes):
            node_id = nd.get("node_id")
            delay_ms = nd.get("delay_ms")
            if not isinstance(node_id, int) or node_id < 0:
                raise ValueError(f"Invalid node_id: {node_id}")
            if not isinstance(delay_ms, int) or delay_ms < 0:
                raise ValueError(f"Invalid delay_ms: {delay_ms}")
            node_arr[i].node_id = node_id
            node_arr[i].delay_ms = delay_ms
            node_arr[i].x = 0.0  # not used in backend
            node_arr[i].y = 0.0
            node_arr[i].radius = 0

        for j, ed in enumerate(edges):
            from_id = ed.get("from_id")
            to_id   = ed.get("to_id")
            if not isinstance(from_id, int) or from_id < 0:
                raise ValueError(f"Invalid from_id: {from_id}")
            if not isinstance(to_id, int) or to_id < 0:
                raise ValueError(f"Invalid to_id: {to_id}")
            edge_arr[j].from_id = from_id
            edge_arr[j].to_id   = to_id

        rc = lib.antnet_update_topology(self.context_id, node_arr, n, edge_arr, e)
        if rc == ERR_SUCCESS:
            return
        elif rc < 0:
            raise ValueError(f"update_topology failed with code {rc}")
        else:
            raise RuntimeError(f"update_topology returned unexpected code {rc}")

    def run_all_solvers(self):
        """
        Runs the ACO, random, and brute force solvers in a single call,
        returning a dictionary with results for each approach.
        """
        max_nodes = 1024
        a_nodes = ffi.new("int[]", max_nodes)
        r_nodes = ffi.new("int[]", max_nodes)
        b_nodes = ffi.new("int[]", max_nodes)

        a_len = ffi.new("int*")
        r_len = ffi.new("int*")
        b_len = ffi.new("int*")
        a_lat = ffi.new("int*")
        r_lat = ffi.new("int*")
        b_lat = ffi.new("int*")

        rc = lib.antnet_run_all_solvers(
            self.context_id,
            a_nodes, max_nodes, a_len, a_lat,
            r_nodes, max_nodes, r_len, r_lat,
            b_nodes, max_nodes, b_len, b_lat
        )
        if rc == ERR_SUCCESS:
            return {
                "aco": {
                    "nodes": [a_nodes[i] for i in range(a_len[0])],
                    "total_latency": a_lat[0]
                },
                "random": {
                    "nodes": [r_nodes[i] for i in range(r_len[0])],
                    "total_latency": r_lat[0]
                },
                "brute": {
                    "nodes": [b_nodes[i] for i in range(b_len[0])],
                    "total_latency": b_lat[0]
                },
            }
        elif rc < 0:
            raise ValueError(f"run_all_solvers failed with code {rc}")
        else:
            raise RuntimeError(f"run_all_solvers returned unexpected code {rc}")

    def get_pheromone_matrix(self) -> list[float]:
        """
        get_pheromone_matrix: retrieves the entire pheromone matrix as a flat float list.
        size = n*n, where n = aco_v1.pheromone_size in C.
        Raises ValueError if an error occurs (negative return code).
        """
        if self.context_id is None:
            raise ValueError("No valid context_id to get pheromone matrix.")
        size = 1024 * 1024  # safe upper bound
        buf = ffi.new("float[]", size)
        rc = lib.antnet_get_pheromone_matrix(self.context_id, buf, size)
        if rc < 0:
            raise ValueError(f"get_pheromone_matrix failed with code {rc}")
        return [buf[i] for i in range(rc)]

    def shutdown(self):
        if self.context_id is not None:
            rc = lib.antnet_shutdown(self.context_id)
            if rc == ERR_SUCCESS:
                self.context_id = None
            elif rc < 0:
                raise ValueError(f"antnet_shutdown failed with code {rc}")
            else:
                raise RuntimeError(f"antnet_shutdown returned unexpected code {rc}")

    def __del__(self):
        """
        Ensure we release the context when this object is GCed.
        """
        try:
            self.shutdown()
        except:
            pass
'''

TEMPLATE_AFTER = r'''
# Global state for the async renderer. This ensures we init exactly once.
_renderer_initialized = False

def init_async_renderer(width: int = 64, height: int = 64) -> None:
    """
    Initializes the persistent background renderer.
    Safe to call multiple times; the second time is no-op.
    """
    global _renderer_initialized
    if _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_init(width, height)
    if rc == 0:
        _renderer_initialized = True
    else:
        raise RuntimeError(f"init_async_renderer failed with code {rc}")

def shutdown_async_renderer() -> None:
    """
    Stops the background renderer thread. Safe to call more than once.
    """
    global _renderer_initialized
    if not _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_shutdown()
    if rc == 0:
        _renderer_initialized = False
    else:
        raise RuntimeError(f"shutdown_async_renderer failed with code {rc}")

def render_heatmap_rgba(
    pts_xy: list[float],
    strength: list[float],
    width: int,
    height: int
) -> bytes:
    """
    Renders a heatmap from a point cloud and strength values using the GPU (OpenGL ES + EGL).
    This function is fully decoupled from AntNetWrapper and may be called from any thread.

    Uses a persistent background thread to avoid interfering with Qt.
    """
    # Ensure the async renderer is started
    init_async_renderer()

    if len(pts_xy) % 2 != 0:
        raise ValueError("pts_xy must be a flat list of x,y pairs (even length)")

    n = len(strength)
    if len(pts_xy) != 2 * n:
        raise ValueError("length mismatch: len(pts_xy) must be 2×len(strength)")

    c_pts = ffi.new("float[]", pts_xy)
    c_str = ffi.new("float[]", strength)
    c_buf = ffi.new("unsigned char[]", width * height * 4)

    rc = lib.antnet_render_heatmap_rgba(c_pts, c_str, n, c_buf, width, height)
    if rc != ERR_SUCCESS:
        raise RuntimeError(f"heatmap render failed with code {rc}")

    return ffi.buffer(c_buf, width * height * 4)[:]
'''

# ───────────────────────── Parsing Logic ────────────────────────────
FUNC_RE = re.compile(r"^\s*[\w\s\*]+\s+(antnet_\w+)\s*\(", re.MULTILINE)

def load_cdefs() -> list[str]:
    """
    Loads the raw C definitions from cdef_string.py, returns all antnet_*
    function names found via regex.
    """
    spec = importlib.util.spec_from_file_location("_cdef", CDEF_PY)
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)  # type: ignore
    cdef_raw = mod.CDEF_SOURCE  # type: ignore[attr-defined]

    return sorted(set(m.group(1) for m in FUNC_RE.finditer(cdef_raw)))

def detect_existing_wrappers() -> set[str]:
    """
    Parse the existing output file (backend_api.py) as an AST,
    searching for calls of the form lib.antnet_<something>.
    Because the manual code uses custom method names for these calls,
    we cannot rely on def-names. Instead, we look for any usage:

        lib.antnet_foo(self.context_id, ...)

    If found, we consider 'antnet_foo' "implemented."
    """
    if not OUTPUT.exists():
        return set()

    tree = ast.parse(OUTPUT.read_text(encoding="utf-8"))
    found = set()

    for node in ast.walk(tree):
        # We're looking for calls or attribute usage referencing "lib.<function>"
        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
            attr = node.func.attr  # e.g. antnet_run_iteration
            if attr.startswith("antnet_"):
                found.add(attr)
    return found

def generate_wrapper(fname: str) -> str:
    """
    Creates an auto-generated minimal wrapper for any newly added function
    that is not yet accounted for in the manual code. If you want custom logic,
    you can edit this function or handle that function manually in the template.
    """
    stub = f'''
def {fname}(self, *args):
    """
    AUTO-GENERATED stub for lib.{fname}.
    Edit this manually if you need custom argument/return logic.
    """
    if self.context_id is None:
        raise ValueError("No valid context_id for {fname}.")
    rc = lib.{fname}(self.context_id, *args)
    if rc == ERR_SUCCESS or rc == 0:
        return rc
    if rc < 0:
        raise ValueError("{fname} failed with code {{rc}}")
    raise RuntimeError("{fname} returned unexpected code {{rc}}")
'''
    return indent(stub.strip("\n"), "    ")

# ────────────────────────────── Main ───────────────────────────────
def main() -> None:
    all_funcs = load_cdefs()
    existing = detect_existing_wrappers()

    # Any function not yet implemented in the template is "missing"
    missing = [f for f in all_funcs if f not in existing]

    # Generate stubs for missing ones
    if missing:
        block = "\n\n".join(generate_wrapper(fname) for fname in missing)
    else:
        block = "    # (all antnet_* functions accounted for in manual code)"

    # Create final combined text
    full_output = TEMPLATE_BEFORE + "\n\n" + block + "\n\n" + TEMPLATE_AFTER

    # Write to disk
    OUTPUT.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT.write_text(full_output, encoding="utf-8")

    # Also write a short report
    REPORT.parent.mkdir(parents=True, exist_ok=True)
    REPORT.write_text(
        f"Total CDEF functions : {len(all_funcs)}\n"
        f"Already implemented  : {len(existing)}\n"
        f"Wrappers generated   : {len(missing)}\n"
        f"Output file          : {OUTPUT}\n",
        encoding="utf-8"
    )

    print(f"✅ {OUTPUT.name} regenerated with {len(missing)} new wrapper(s).")
    print(f"[i] Report written to {REPORT}")

if __name__ == "__main__":
    main()
