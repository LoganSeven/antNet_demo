#!/usr/bin/env python3
# src/python/tools/backend_end_api_builder.py
"""
Re-generates src/python/ffi/backend_api.py every build.

 ▸ TEMPLATE_BEFORE  – manual code maintained by developers  
 ▸ TEMPLATE_AFTER   – utility helpers (heat-map, async renderer, …)  
 ▸ Between them the script auto-inserts wrappers for every lib.antnet_* function
   that is present in cdef_string.py but NOT referenced in TEMPLATE_BEFORE.
"""

from __future__ import annotations

import ast
import importlib.util
import re
import sys
from pathlib import Path
from textwrap import indent

# ────────────────────────────── Paths ──────────────────────────────
ROOT     = Path(__file__).resolve().parents[3]
CDEF_PY  = ROOT / "src/python/ffi/cdef_string.py"
OUTPUT   = ROOT / "src/python/ffi/backend_api.py"
REPORT   = ROOT / "build/api_autogen_report.txt"

# ─────────────────────────── TEMPLATES ─────────────────────────────
TEMPLATE_BEFORE = r'''# src/python/ffi/backend_api.py
# High-level Python wrapper for the C AntNet backend.
# security/hardening: negative C return code ⇒ ValueError
# unexpected positive non-zero ⇒ RuntimeError

from __future__ import annotations
import os
import sys
import importlib

from consts._generated.error_codes_generated import ERR_SUCCESS
from structs._generated.auto_structs import AppConfig  # generated by tools/generate_structs.py

# ----------------------------------------------------------------------
#  Dynamic import of backend_cffi (the CFFI-generated glue module)
# ----------------------------------------------------------------------
def _ensure_backend_cffi_loaded():
    """
    Attempt to import backend_cffi.  
    If not found, prepend common build paths to sys.path and retry exactly once.
    """
    try:
        return importlib.import_module("backend_cffi")
    except ModuleNotFoundError:
        here = os.path.dirname(__file__)
        root = os.path.abspath(os.path.join(here, "..", "..", ".."))
        for p in (
            os.path.join(root, "build", "python"),
            os.path.join(root, "src",  "python"),
            os.path.join(root, "src",  "python", "ffi"),
        ):
            if p not in sys.path and os.path.isdir(p):
                sys.path.insert(0, p)
        return importlib.import_module("backend_cffi")

_backend = _ensure_backend_cffi_loaded()
ffi, lib = _backend.ffi, _backend.lib  # type: ignore

# ----------------------------------------------------------------------
#  AntNetWrapper – thin, pythonic façade over the native API
# ----------------------------------------------------------------------
class AntNetWrapper:
    """
    Wrapper supports three constructors:
        AntNetWrapper.from_config("file.ini")
        AntNetWrapper(app_config={…})
        AntNetWrapper(node_count, min_hops, max_hops)
    """

    # ─────────────────────────────── ctor ────────────────────────────
    def __init__(
        self,
        node_count: int | None = None,
        min_hops:   int | None = None,
        max_hops:   int | None = None,
        from_config: str | None = None,
        app_config:  dict | None = None,
    ):
        self.context_id: int | None = None

        # 1) ini-file
        if from_config is not None:
            if not isinstance(from_config, str):
                raise ValueError("from_config must be a str path to .ini")
            rc = lib.antnet_init_from_config(from_config.encode("utf-8"))
            if rc < 0:
                raise ValueError(f"antnet_init_from_config failed with code {rc}")
            self.context_id = rc
            return

        # 2) dict-based config
        if app_config is not None:
            if not isinstance(app_config, dict):
                raise ValueError("app_config must be a dict")
            node_count = app_config["set_nb_nodes"]
            min_hops   = app_config["min_hops"]
            max_hops   = app_config["max_hops"]

        # 3) raw numbers
        if node_count is not None and min_hops is not None and max_hops is not None:
            rc = lib.antnet_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"antnet_initialize failed with code {rc}")
            self.context_id = rc
            return

        raise ValueError(
            "Need either from_config=…, or app_config=…, "
            "or node_count/min_hops/max_hops."
        )

    # convenience
    @classmethod
    def from_config(cls, path: str) -> "AntNetWrapper":
        return cls(from_config=path)

    # ─────────────────────── configuration read ─────────────────────
    def get_config(self) -> AppConfig:
        if self.context_id is None:
            raise ValueError("No valid context_id")
        cfg_ptr = ffi.new("AppConfig*")
        rc = lib.antnet_get_config(self.context_id, cfg_ptr)
        if rc != 0:
            raise ValueError(f"antnet_get_config failed with code {rc}")
        return {
            "nb_swarms":              cfg_ptr.nb_swarms,
            "set_nb_nodes":           cfg_ptr.set_nb_nodes,
            "min_hops":               cfg_ptr.min_hops,
            "max_hops":               cfg_ptr.max_hops,
            "default_delay":          cfg_ptr.default_delay,
            "death_delay":            cfg_ptr.death_delay,
            "under_attack_id":        cfg_ptr.under_attack_id,
            "attack_started":         bool(cfg_ptr.attack_started),
            "simulate_ddos":          bool(cfg_ptr.simulate_ddos),
            "show_random_performance": bool(cfg_ptr.show_random_performance),
            "show_brute_performance":  bool(cfg_ptr.show_brute_performance),
        }

    # ────────────────────────── iteration ───────────────────────────
    def run_iteration(self) -> None:
        rc = lib.antnet_run_iteration(self.context_id)
        if rc == ERR_SUCCESS:
            return
        if rc < 0:
            raise ValueError(f"run_iteration failed with code {rc}")
        raise RuntimeError(f"run_iteration returned unexpected {rc}")

    # ─────────────────────── best-path helper ───────────────────────
    def get_best_path_struct(self):
        max_nodes = 1024
        nodes_buf = ffi.new("int[]", max_nodes)
        len_ptr   = ffi.new("int*")
        lat_ptr   = ffi.new("int*")

        rc = lib.antnet_get_best_path(self.context_id, nodes_buf, max_nodes, len_ptr, lat_ptr)
        if rc != ERR_SUCCESS:
            raise ValueError(f"get_best_path failed with code {rc}")
        return {
            "nodes": [nodes_buf[i] for i in range(len_ptr[0])],
            "total_latency": lat_ptr[0],
        }

    # ───────────────────── topology replacement ─────────────────────
    def update_topology(self, nodes: list[dict], edges: list[dict]) -> None:
        """
        Push a new node/edge array into the backend.
        Each node  → {"node_id": int >=0, "delay_ms": int >=0}
        Each edge  → {"from_id": int >=0, "to_id":   int >=0}
        """
        if self.context_id is None:
            raise ValueError("Invalid context_id")

        n, e = len(nodes), len(edges)
        if n == 0 or e == 0:
            raise ValueError("Empty node or edge list")

        node_arr = ffi.new("NodeData[]", n)
        edge_arr = ffi.new("EdgeData[]", e)

        for i, nd in enumerate(nodes):
            node_id  = nd.get("node_id")
            delay_ms = nd.get("delay_ms")
            if not isinstance(node_id, int) or node_id < 0:
                raise ValueError(f"Invalid node_id: {node_id}")
            if not isinstance(delay_ms, int) or delay_ms < 0:
                raise ValueError(f"Invalid delay_ms: {delay_ms}")
            node_arr[i].node_id  = node_id
            node_arr[i].delay_ms = delay_ms
            node_arr[i].x = node_arr[i].y = 0.0
            node_arr[i].radius = 0

        for j, ed in enumerate(edges):
            from_id = ed.get("from_id")
            to_id   = ed.get("to_id")
            if not isinstance(from_id, int) or from_id < 0:
                raise ValueError(f"Invalid from_id: {from_id}")
            if not isinstance(to_id, int) or to_id < 0:
                raise ValueError(f"Invalid to_id: {to_id}")
            edge_arr[j].from_id = from_id
            edge_arr[j].to_id   = to_id

        rc = lib.antnet_update_topology(self.context_id, node_arr, n, edge_arr, e)
        if rc == ERR_SUCCESS:
            return
        if rc < 0:
            raise ValueError(f"update_topology failed with code {rc}")
        raise RuntimeError(f"update_topology returned unexpected {rc}")

    # ───────────────────── run all solvers in C ─────────────────────
    def run_all_solvers(self):
        max_nodes = 1024
        a_nodes = ffi.new("int[]", max_nodes)
        r_nodes = ffi.new("int[]", max_nodes)
        b_nodes = ffi.new("int[]", max_nodes)

        a_len = ffi.new("int*"); r_len = ffi.new("int*"); b_len = ffi.new("int*")
        a_lat = ffi.new("int*"); r_lat = ffi.new("int*"); b_lat = ffi.new("int*")

        rc = lib.antnet_run_all_solvers(
            self.context_id,
            a_nodes, max_nodes, a_len, a_lat,
            r_nodes, max_nodes, r_len, r_lat,
            b_nodes, max_nodes, b_len, b_lat
        )
        if rc != ERR_SUCCESS:
            raise ValueError(f"run_all_solvers failed with code {rc}")

        return {
            "aco": {
                "nodes": [a_nodes[i] for i in range(a_len[0])],
                "total_latency": a_lat[0],
            },
            "random": {
                "nodes": [r_nodes[i] for i in range(r_len[0])],
                "total_latency": r_lat[0],
            },
            "brute": {
                "nodes": [b_nodes[i] for i in range(b_len[0])],
                "total_latency": b_lat[0],
            },
        }

    # ───────────────────── pheromone matrix read ────────────────────
    def get_pheromone_matrix(self) -> list[float]:
        if self.context_id is None:
            raise ValueError("Invalid context_id")
        max_floats = 1024 * 1024
        buf = ffi.new("float[]", max_floats)
        rc  = lib.antnet_get_pheromone_matrix(self.context_id, buf, max_floats)
        if rc < 0:
            raise ValueError(f"get_pheromone_matrix failed with code {rc}")
        return [buf[i] for i in range(rc)]

    # ─────────────────────────── ranking ────────────────────────────
    def get_algo_ranking(self) -> list[dict]:
        if self.context_id is None:
            raise ValueError("Invalid context_id")
        max_algs = 8
        rank_arr = ffi.new("RankingEntry[]", max_algs)
        rc = lib.antnet_get_algo_ranking(self.context_id, rank_arr, max_algs)
        if rc < 0:
            raise ValueError(f"get_algo_ranking failed with code {rc}")
        result: list[dict] = []
        for i in range(rc):
            name = ffi.string(rank_arr[i].name).decode("utf-8", "ignore")
            result.append({
                "name":       name,
                "score":      rank_arr[i].score,
                "latency_ms": rank_arr[i].latency_ms,
            })
        return result

    # ───────────────────────── shutdown ─────────────────────────────
    def shutdown(self) -> None:
        if self.context_id is None:
            return
        rc = lib.antnet_shutdown(self.context_id)
        if rc == ERR_SUCCESS:
            self.context_id = None
            return
        if rc < 0:
            raise ValueError(f"antnet_shutdown failed with code {rc}")
        raise RuntimeError(f"antnet_shutdown returned unexpected {rc}")

    def __del__(self):
        try:
            self.shutdown()
        except Exception:
            pass
'''

# -------------- TEMPLATE_AFTER unchanged (async renderer helpers) --------------
TEMPLATE_AFTER = r'''
# ───────────────────── GPU async renderer helpers ─────────────────────
_renderer_initialized = False

def init_async_renderer(width: int = 64, height: int = 64) -> None:
    global _renderer_initialized
    if _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_init(width, height)
    if rc != 0:
        raise RuntimeError(f"antnet_renderer_async_init failed with code {rc}")
    _renderer_initialized = True

def shutdown_async_renderer() -> None:
    global _renderer_initialized
    if not _renderer_initialized:
        return
    rc = lib.antnet_renderer_async_shutdown()
    if rc != 0:
        raise RuntimeError(f"antnet_renderer_async_shutdown failed with code {rc}")
    _renderer_initialized = False

def render_heatmap_rgba(
    pts_xy:   list[float],
    strength: list[float],
    width: int,
    height: int
) -> bytes:
    """
    Render a heat-map into an RGBA buffer (width×height×4 bytes).
    """
    init_async_renderer()

    if len(pts_xy) != 2 * len(strength):
        raise ValueError("pts_xy length must be 2×len(strength)")
    if len(pts_xy) % 2:
        raise ValueError("pts_xy length must be even")

    c_pts = ffi.new("float[]", pts_xy)
    c_str = ffi.new("float[]", strength)
    buf   = ffi.new("unsigned char[]", width * height * 4)

    rc = lib.antnet_render_heatmap_rgba(c_pts, c_str, len(strength),
                                        buf, width, height)
    if rc != ERR_SUCCESS:
        raise RuntimeError(f"antnet_render_heatmap_rgba failed with code {rc}")

    return ffi.buffer(buf, width * height * 4)[:]
'''

# ───────────────────────── Parsing Logic ────────────────────────────
FUNC_RE = re.compile(r"^\s*[\w\s\*]+\s+(antnet_\w+)\s*\(", re.MULTILINE)

def load_cdefs() -> list[str]:
    spec = importlib.util.spec_from_file_location("_cdef", CDEF_PY)
    mod  = importlib.util.module_from_spec(spec)  # type: ignore
    spec.loader.exec_module(mod)                 # type: ignore
    return sorted({m.group(1) for m in FUNC_RE.finditer(mod.CDEF_SOURCE)})  # type: ignore

def detect_existing_wrappers() -> set[str]:
    if not OUTPUT.exists():
        return set()
    tree = ast.parse(OUTPUT.read_text(encoding="utf-8"))
    return {
        node.func.attr                       # type: ignore[attr-defined]
        for node in ast.walk(tree)
        if isinstance(node, ast.Call)
        and isinstance(node.func, ast.Attribute)
        and node.func.attr.startswith("antnet_")
    }

def generate_wrapper(fname: str) -> str:
    stub = f"""
def {fname}(self, *args):
    \"\"\"AUTO-GENERATED thin wrapper for lib.{fname}.\"\"\"
    if self.context_id is None:
        raise ValueError("Invalid context_id for {fname}")
    rc = lib.{fname}(self.context_id, *args)
    if rc in (0, ERR_SUCCESS):
        return rc
    if rc < 0:
        raise ValueError("{fname} failed with code {{rc}}")
    raise RuntimeError("{fname} returned unexpected {{rc}}")
"""
    return indent(stub.strip(), "    ")

# ────────────────────────────── Main ───────────────────────────────
def main() -> None:
    all_funcs = load_cdefs()
    implemented = detect_existing_wrappers()
    missing = [f for f in all_funcs if f not in implemented]

    auto_block = (
        "\n\n".join(generate_wrapper(f) for f in missing)
        if missing else
        "    # (all antnet_* functions accounted for in manual code)"
    )

    OUTPUT.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT.write_text(TEMPLATE_BEFORE + "\n\n" + auto_block + "\n\n" + TEMPLATE_AFTER,
                      encoding="utf-8")

    REPORT.parent.mkdir(parents=True, exist_ok=True)
    REPORT.write_text(
        f"Total antnet_* in CDEF   : {len(all_funcs)}\n"
        f"Already implemented      : {len(implemented)}\n"
        f"Wrappers auto-generated  : {len(missing)}\n",
        encoding="utf-8",
    )

    print(f"✅ backend_api.py regenerated ({len(missing)} auto-wrapper(s) added).")

if __name__ == "__main__":
    main()
