#!/usr/bin/env python3
# Relative Path: src/python/tools/backend_end_api_builder.py
#
# Ensures 'backend_api.py' contains wrappers for all C functions declared
# with a 'pub_' prefix in 'cdef_string.py'.
#
# Behavior:
# 1. If 'backend_api.py' does not exist, creates a minimal valid file.
# 2. Scans 'cdef_string.py' for pub_* C functions.
# 3. Identifies missing Python wrappers in AntNetWrapper.
# 4. For each missing wrapper, appends a minimal method.
#
# Notes:
# - pub_ prefix is removed in Python method name.
# - Each new method prints a red reminder to complete implementation.
# - Wrapper uses standard return code pattern for int/_Bool.
# - Functions without context_id are also supported.

import os
import re
import sys
from pathlib import Path

# ----------------------------------------------------------------------
# Paths
# ----------------------------------------------------------------------
ROOT = Path(__file__).resolve().parents[3]
CDEF_FILE = ROOT / "src/python/ffi/cdef_string.py"
BACKEND_API_FILE = ROOT / "src/python/ffi/backend_api.py"

BASE_BACKEND_API = r'''# Relative Path: src/python/ffi/backend_api.py
# High-level Python wrapper for the C AntNet backend.

from __future__ import annotations
import os
import sys
import importlib

from consts._generated.error_codes_generated import ERR_SUCCESS
from structs._generated.auto_structs import AppConfig  # generated by tools/generate_structs.py

def _ensure_backend_cffi_loaded():
    try:
        return importlib.import_module("backend_cffi")
    except ModuleNotFoundError:
        here = os.path.dirname(__file__)
        root = os.path.abspath(os.path.join(here, "..", "..", ".."))
        for p in (
            os.path.join(root, "build", "python"),
            os.path.join(root, "src",  "python"),
            os.path.join(root, "src",  "python", "ffi"),
        ):
            if p not in sys.path and os.path.isdir(p):
                sys.path.insert(0, p)
        return importlib.import_module("backend_cffi")

_backend = _ensure_backend_cffi_loaded()
ffi, lib = _backend.ffi, _backend.lib  # type: ignore

class AntNetWrapper:
    def __init__(
        self,
        node_count: int | None = None,
        min_hops:   int | None = None,
        max_hops:   int | None = None,
        from_config: str | None = None,
        app_config:  dict | None = None,
    ):
        self.context_id: int | None = None

        if from_config is not None:
            rc = lib.pub_init_from_config(from_config.encode("utf-8"))
            if rc < 0:
                raise ValueError(f"pub_init_from_config failed with code {rc}")
            self.context_id = rc
            return

        if app_config is not None:
            node_count = app_config["set_nb_nodes"]
            min_hops   = app_config["min_hops"]
            max_hops   = app_config["max_hops"]

        if node_count is not None and min_hops is not None and max_hops is not None:
            rc = lib.pub_initialize(node_count, min_hops, max_hops)
            if rc < 0:
                raise ValueError(f"pub_initialize failed with code {rc}")
            self.context_id = rc
            return

        raise ValueError("Must specify from_config, app_config, or 3 raw arguments")

    @classmethod
    def from_config(cls, path: str) -> "AntNetWrapper":
        return cls(from_config=path)
'''

FUNC_RE = re.compile(
    r"""^\s*(?P<ret_type>[\w\s\*]+?)\s+(?P<fn_name>pub_\w+)\s*\((?P<params>[^)]*)\)\s*;""",
    re.MULTILINE
)

DEF_RE = re.compile(r"^\s*def\s+(\w+)\s*\(", re.MULTILINE)


def ensure_backend_api_file():
    if not BACKEND_API_FILE.exists():
        BACKEND_API_FILE.parent.mkdir(parents=True, exist_ok=True)
        BACKEND_API_FILE.write_text(BASE_BACKEND_API, encoding="utf-8")
        print(f"🆕 Created base file: {BACKEND_API_FILE}")


def parse_pub_functions() -> dict:
    content = CDEF_FILE.read_text(encoding="utf-8")
    out = {}
    for match in FUNC_RE.finditer(content):
        ret = match.group("ret_type").strip()
        name = match.group("fn_name").strip()
        params = [p.strip() for p in match.group("params").split(",") if p.strip()]
        out[name] = {"ret": ret, "params": params}
    return out


def detect_existing_wrappers() -> set:
    code = BACKEND_API_FILE.read_text(encoding="utf-8")
    part = code.split("class AntNetWrapper", 1)[-1]
    return {m.group(1) for m in DEF_RE.finditer(part)}


def build_stub(c_name: str, ret: str, param_list: list[str]) -> str:
    py_name = c_name.replace("pub_", "")
    has_context = any("context_id" in p for p in param_list)

    py_params = []
    c_args = []

    for decl in param_list:
        parts = decl.replace("*", " * ").split()
        if not parts:
            continue
        pname = parts[-1].lstrip("*")
        if pname == "context_id":
            continue
        py_params.append(pname)
        c_args.append(pname)

    if has_context:
        c_args.insert(0, "self.context_id")

    param_str = ", ".join(py_params)
    call = f"lib.{c_name}({', '.join(c_args)})"

    lines = [f"# AUTO-GENERATED stub for {c_name}"]
    lines.append(f"def {py_name}(self{', ' + param_str if param_str else ''}):")
    lines.append(f'    """Thin wrapper for lib.{c_name}()"""')
    lines.append(f'    print("🟥 {c_name} → {py_name} — PLEASE COMPLETE IMPLEMENTATION 🟥")')
    if has_context:
        lines.append(f"    if self.context_id is None:")
        lines.append(f"        raise ValueError(\"Invalid context_id for {py_name}\")")

    if ret in ("int", "_Bool"):
        lines.append(f"    rc = {call}")
        lines.append(f"    if rc in (0, ERR_SUCCESS): return rc")
        lines.append(f"    if rc < 0: raise ValueError(\"{py_name} failed with code {{rc}}\")")
        lines.append(f"    raise RuntimeError(\"{py_name} returned unexpected {{rc}}\")")
    else:
        lines.append(f"    {call}")

    return "\n".join(lines) + "\n"


def main():
    if not CDEF_FILE.exists():
        print("❌ cdef_string.py not found")
        sys.exit(1)

    ensure_backend_api_file()

    all_pub = parse_pub_functions()
    existing = detect_existing_wrappers()

    missing = []
    for cname, meta in sorted(all_pub.items()):
        py_name = cname.replace("pub_", "")
        if py_name not in existing:
            stub = build_stub(cname, meta["ret"], meta["params"])
            missing.append(stub)

    if not missing:
        print("✅ backend_api.py already up to date")
        return

    content = BACKEND_API_FILE.read_text(encoding="utf-8").rstrip()
    content += "\n\n" + "\n\n".join(missing) + "\n"
    BACKEND_API_FILE.write_text(content, encoding="utf-8")

    for stub in missing:
        sig_line = stub.splitlines()[1]
        print(f"🛠️  Added wrapper: {sig_line.strip()}")

    print(f"✅ {len(missing)} method(s) appended to backend_api.py")


if __name__ == "__main__":
    main()
